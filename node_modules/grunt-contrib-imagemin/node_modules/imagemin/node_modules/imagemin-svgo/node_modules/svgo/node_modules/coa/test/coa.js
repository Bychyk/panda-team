var assert = require('chai').assert,
    COA = require('..');

/**
 * Mocha BDD interface.
 */
/** @name describe @function */
/** @name it @function */
/** @name before @function */
/** @name after @function */
/** @name beforeEach @function */
/** @name afterEach @function */

describe('Opt', function() {

    describe('Unknown option', function() {

        var cmd = COA.Cmd();

        it('should fail', function() {
            return cmd.do(['-a'])
                .then(assert.fail, emptyFn);
        });

    });

    describe('Short options', function() {

        var cmd = COA.Cmd()
            .opt()
                .name('a')
                .short('a')
                .end()
            .opt()
                .name('b')
                .short('b')
                .end()
            .act(function(opts) {
                return opts;
            });

        it('should return passed values', function() {
            return cmd.do(['-a', 'a', '-b', 'b'])
                .then(function(res) {
                    assert.deepEqual(res, { a: 'a', b: 'b' });
                });
        });

    });

    describe('Long options', function() {

        var cmd = COA.Cmd()
            .opt()
                .name('long1')
                .long('long1')
                .end()
            .opt()
                .name('long2')
                .long('long2')
                .end()
            .act(function(opts) {
                return opts;
            });

        it('should return passed values', function() {
            return cmd.do(['--long1', 'long value', '--long2=another long value'])
                .then(function(res) {
                    assert.deepEqual(res, { long1: 'long value', long2: 'another long value' });
                });
        });

    });

    describe('Array option', function() {

        var cmd = COA.Cmd()
            .opt()
                .name('a')
                .short('a')
                .arr()
                .end()
            .act(function(opts) {
                return opts;
            });

        it('should return array of passed values', function() {
            return cmd.do(['-a', '1', '-a', '2'])
                .then(function(res) {
                    assert.deepEqual(res, { a: ['1', '2'] });
                });
        });

    });

    describe('Required option', function() {

        var cmd = COA.Cmd()
            .opt()
                .name('a')
                .short('a')
                .req()
                .end()
            .act(function(opts) {
                return opts;
            });

        it('should fail if not specified', function() {
            return cmd.do()
                .then(assert.fail, emptyFn);
        });

        it('should return passed value if specified', function() {
            return cmd.do(['-a', 'test'])
                .then(function(opts) {
                    assert.equal(opts.a, 'test');
                });
        });

    });

    describe('Option with default value', function() {

        var cmd = COA.Cmd()
            .opt()
                .name('a')
                .short('a')
                .def('aaa')
                .end()
            .act(function(opts) {
                return opts;
            });

        it('should return default value if not specified', function() {
            return cmd.do()
                .then(function(opts) {
                    assert.equal(opts.a, 'aaa');
                });
        });

        it('should return passed value if specified', function() {
            return cmd.do(['-a', 'test'])
                .then(function(opts) {
                    assert.equal(opts.a, 'test');
                });
        });

    });

    describe('Validated / transformed option', function() {

        var cmd = COA.Cmd()
            .opt()
                .name('a')
                .short('a')
                .val(function(v) {
                    if (v === 'invalid') return this.reject('fail');
                    return { value: v };
                })
                .end()
            .act(fun